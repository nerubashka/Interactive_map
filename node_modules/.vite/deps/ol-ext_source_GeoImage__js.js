import {
  ImageCanvas_default
} from "./chunk-EWVOED46.js";
import "./chunk-3YGWTNAX.js";
import {
  Polygon_default,
  fromExtent
} from "./chunk-5UO32OHN.js";
import "./chunk-LGZ6M6P3.js";
import "./chunk-6LTSYPXT.js";
import "./chunk-FZ7WLJSJ.js";
import "./chunk-DRTCU4B3.js";
import "./chunk-T2CB2VSQ.js";
import "./chunk-AEWXZ3WW.js";
import {
  boundingExtent
} from "./chunk-WQSEWMRT.js";
import "./chunk-5TDNKDLD.js";
import "./chunk-YZOGOUHU.js";
import "./chunk-ZHG2RUY5.js";
import "./chunk-X2MHPXID.js";
import "./chunk-PAQUSFNP.js";
import "./chunk-2UTYCOSM.js";
import "./chunk-HUBM7RA2.js";

// node_modules/ol-ext/source/GeoImage.js
var ol_source_GeoImage = class olsourceGeoImage extends ImageCanvas_default {
  constructor(opt_options) {
    var options = {
      attributions: opt_options.attributions,
      logo: opt_options.logo,
      projection: opt_options.projection
    };
    options.canvasFunction = function(extent, resolution, pixelRatio, size) {
      return this.calculateImage(extent, resolution, pixelRatio, size);
    };
    super(options);
    this._image = opt_options.image ? opt_options.image : new Image();
    this._image.crossOrigin = opt_options.crossOrigin;
    this._image.onload = function() {
      this.setCrop(this.crop);
      this.changed();
    }.bind(this);
    if (!opt_options.image)
      this._image.src = opt_options.url;
    this.center = opt_options.imageCenter;
    this.setScale(opt_options.imageScale);
    this.rotate = opt_options.imageRotate ? opt_options.imageRotate : 0;
    this.crop = opt_options.imageCrop;
    this.mask = opt_options.imageMask;
    this.setCrop(this.crop);
    this.on("change", function() {
      this.set("extent", this.calculateExtent());
    }.bind(this));
  }
  calculateImage(extent, resolution, pixelRatio, size) {
    if (!this.center)
      return;
    var canvas = document.createElement("canvas");
    canvas.width = size[0];
    canvas.height = size[1];
    var ctx = canvas.getContext("2d");
    if (!this._imageSize)
      return canvas;
    function tr(xy) {
      return [
        (xy[0] - extent[0]) / (extent[2] - extent[0]) * size[0],
        (xy[1] - extent[3]) / (extent[1] - extent[3]) * size[1]
      ];
    }
    if (this.mask) {
      ctx.beginPath();
      var p = tr(this.mask[0]);
      ctx.moveTo(p[0], p[1]);
      for (var i = 1; i < this.mask.length; i++) {
        p = tr(this.mask[i]);
        ctx.lineTo(p[0], p[1]);
      }
      ctx.clip();
    }
    var pixel = tr(this.center);
    var dx = (this._image.naturalWidth / 2 - this.crop[0]) * this.scale[0] / resolution * pixelRatio;
    var dy = (this._image.naturalHeight / 2 - this.crop[1]) * this.scale[1] / resolution * pixelRatio;
    var sx = this._imageSize[0] * this.scale[0] / resolution * pixelRatio;
    var sy = this._imageSize[1] * this.scale[1] / resolution * pixelRatio;
    ctx.translate(pixel[0], pixel[1]);
    if (this.rotate)
      ctx.rotate(this.rotate);
    ctx.drawImage(this._image, this.crop[0], this.crop[1], this._imageSize[0], this._imageSize[1], -dx, -dy, sx, sy);
    return canvas;
  }
  getCenter() {
    return this.center;
  }
  setCenter(center) {
    this.center = center;
    this.changed();
  }
  getScale() {
    return this.scale;
  }
  setScale(scale) {
    switch (typeof scale) {
      case "number":
        scale = [scale, scale];
        break;
      case "object":
        if (scale.length != 2)
          return;
        break;
      default:
        return;
    }
    this.scale = scale;
    this.changed();
  }
  getRotation() {
    return this.rotate;
  }
  setRotation(angle) {
    this.rotate = angle;
    this.changed();
  }
  getGeoImage() {
    return this._image;
  }
  getCrop() {
    return this.crop;
  }
  setMask(mask) {
    this.mask = mask;
    this.changed();
  }
  getMask() {
    return this.mask;
  }
  setCrop(crop) {
    if (!this._image.naturalWidth) {
      this.crop = crop;
      return;
    }
    if (crop) {
      switch (typeof crop) {
        case "number":
          crop = [crop, crop, this._image.naturalWidth - crop, this._image.naturalHeight - crop];
          break;
        case "object":
          if (crop.length != 4)
            return;
          break;
        default:
          return;
      }
      crop = boundingExtent([[crop[0], crop[1]], [crop[2], crop[3]]]);
      this.crop = [Math.max(0, crop[0]), Math.max(0, crop[1]), Math.min(this._image.naturalWidth, crop[2]), Math.min(this._image.naturalHeight, crop[3])];
    } else
      this.crop = [0, 0, this._image.naturalWidth, this._image.naturalHeight];
    if (this.crop[2] <= this.crop[0])
      this.crop[2] = this.crop[0] + 1;
    if (this.crop[3] <= this.crop[1])
      this.crop[3] = this.crop[1] + 1;
    this._imageSize = [this.crop[2] - this.crop[0], this.crop[3] - this.crop[1]];
    this.changed();
  }
  getExtent(opt_extent) {
    var ext = this.get("extent");
    if (!ext)
      ext = this.calculateExtent();
    if (opt_extent) {
      for (var i = 0; i < opt_extent.length; i++) {
        opt_extent[i] = ext[i];
      }
    }
    return ext;
  }
  calculateExtent(usemask) {
    var polygon;
    if (usemask !== false && this.getMask()) {
      polygon = new Polygon_default([this.getMask()]);
    } else {
      var center = this.getCenter();
      var scale = this.getScale();
      var width = this.getGeoImage().width * scale[0];
      var height = this.getGeoImage().height * scale[1];
      var extent = boundingExtent([
        [center[0] - width / 2, center[1] - height / 2],
        [center[0] + width / 2, center[1] + height / 2]
      ]);
      polygon = fromExtent(extent);
      polygon.rotate(-this.getRotation(), center);
    }
    var ext = polygon.getExtent();
    return ext;
  }
};
var GeoImage_default = ol_source_GeoImage;
export {
  GeoImage_default as default
};
//# sourceMappingURL=ol-ext_source_GeoImage__js.js.map
